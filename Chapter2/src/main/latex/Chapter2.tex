\documentclass[12pt,notitlepage]{article}
\author{Leo Przybylski}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}

\title{\includegraphics[width=0.75\textwidth]{../../images/rsmart_base.png}\\\includegraphics[width=0.70\textwidth]{../../images/kuali_base.png}\\rSmart
Rice Customizations and Maven}
\pagestyle{fancy}
\fancyhead{} % Clear all header fields 
\fancyhead[OL]{\sectionmark}
\fancyhead[OR]{\includegraphics[height=26pt]{../../images/rsmart_base.png}}% 
\fancyhead[ER]{\sectionmark}
\fancyhead[EL]{\includegraphics[height=26pt]{../../images/rsmart_base.png}}% 
\definecolor{ubergray}{RGB}{245,245,245}
\hypersetup{colorlinks}
\lstset{basicstyle=\scriptsize,
  backgroundcolor=\color{ubergray},
  breaklines=true,
  frame=single,
  includerangemarker=false}
\begin{document}
\maketitle
\tableofcontents

\abstract{When an institution wants to implement customizations and/or fixes from another rice distribution, how do these customizations get pushed out to other projects? The best way is through maven and the institution's Maven repository. The trouble is that Rice is a modular project where modules depend on the parent. It is important to keep the following in mind: \begin{itemize}
\item Original project parents
\item Do not use the org.kuali groupId
\end{itemize}
This document is about how to go about this.}

\section{Red, Green, Refactor, Repeat}
You may have heard of it before. If this is new to you, eventually, it will uttered by you in your sleep as you venture further into Test-Driven Development. According to Martin Fowler, this paradigm is a mixture of two practices, unit testing and refactoring. Before doing any development of our application, we write our unit tests. At this point, the tests don't even compile because the unit tests refer to application classes that don't exist yet. For this reason, unit tests are often referred to as specifications. More than anything else, unit tests reflect the true behavior of the software. They  are also the best-maintained. With tests failing to even compile, they are considered "red" for their failing status. Green comes in when we commit ourselves to making the tests pass by fixing the broken source code. This is further than just getting the tests to compile. It implies that the functionality according to the unit tests we wrote exists in the source code and passes our tests against it. Once our tests are complete, we need to commit ourselves to continuously improving the source code. We do this by applying various refactoring patterns. Then, Red, Green, Refactor, Repeat
You may have heard of it before. If this is new to you, eventually, it will uttered by you in your sleep as you venture further into Test-Driven Development. According to Martin Fowler, this paradigm is a mixture of two practices, unit testing and refactoring. Before doing any development of our application, we write our unit tests. At this point, the tests don't even compile because the unit tests refer to application classes that don't exist yet. For this reason, unit tests are often referred to as specifications. More than anything else, unit tests reflect the true behavior of the software. They  are also the best-maintained. With tests failing to even compile, they are considered "red" for their failing status. Green comes in when we commit ourselves to making the tests pass by fixing the broken source code. This is further than just getting the tests to compile. It implies that the functionality according to the unit tests we wrote exists in the source code and passes our tests against it. Once our tests are complete, we need to commit ourselves to continuously improving the source code. We do this by applying various refactoring patterns. Then, 
\newpage
\listoffigures
\lstlistoflistings
\end{document}